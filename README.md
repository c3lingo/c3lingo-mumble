# Scalable Low Latency Audio Streams for the Chaos Communication Congress

For 34c3, we the translation team needed a new solution to get the simultaneous translations to the in-hall listeners. Previously, that worked through an ingenious hack inside the DECT system. (for more info, ask POC)

With the new location, a new DECT system was needed, which did not have the necessary capabilities anymore. This led us to look into our own solutions. The quickest way to set something up seemed Mumble. This worked surprisingly well, but the audio needs to get from the VOC, where all the audio is aggregated, into our mumble server. This software is exactly that.

## Current tech

### Input

Currently, the audio input is available through AES67. (Audinate's Dante would also be available, but the Windows requirement makes that very undesirable.)
Last year, this was not available, but the VOC gave us a way to grab the multicast AES67 via gstreamer. This is then piped directly into our application.
The audio coming through stdin is read in chunks of 128 bytes and written into a queue.


### Output

The audio packets in the queue are forwarded directly to the PyMumble library, which requires an exact format, which is already dealt with through the gstreamer command. This means that the python code does not have to transcode or resample anything and can just fill the internal pymumble queue which is then fed into the specified channel on the specified server.

### Mumble Authentication

Mumble uses client certificates to authenticates clients. This allows us to have very restrictive ACL's on the server which makes sure only the translation bots can talk in the respective channel. Please refer to the PyMumble library APIdoc to find the commands to convert/split the P12 format generated by the official client into the necessary formats for the PyMumble library.

To convert from PEM certificate and key file to a P12 file, you can use:
```
openssl pkcs12 -export -out certificate.pfx -inkey privateKey.key -in certificate.crt
```
